SELECT DISTINCT TBP.PRODUCT_NAME 
FROM TBL_ORDER TBO
JOIN TBL_PRODUCT TBP 
ON TBO.PRODUCT_ID = TBP.ID;

-- 가상 테이블 DUAL
SELECT 10 FROM DUAL;
SELECT SYSDATE FROM DUAL;

--논리 연산자
SELECT DISTINCT TBP.PRODUCT_NAME 
FROM TBL_ORDER TBO
JOIN TBL_PRODUCT TBP 
ON TBO.PRODUCT_ID = TBP.ID AND TBP.PRODUCT_NAME = '청바지';

-- BETWEEN A AND B ( A부터 B 까지 )
SELECT *
FROM (
	SELECT TBO.*, TBP.PRODUCT_BRAND , TBP.PRODUCT_PRICE 
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID
)
WHERE PRODUCT_PRICE BETWEEN 100000 AND 300000;

-- 같지 않다 
SELECT *
FROM (
	SELECT TBO.*, TBP.PRODUCT_BRAND , TBP.PRODUCT_PRICE 
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID
)
WHERE PRODUCT_PRICE <> 119000;


-- IS NULL : NULL인 데이터
SELECT *
FROM (
	SELECT TBO.*, TBP.PRODUCT_BRAND , TBP.PRODUCT_PRICE 
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID
)
WHERE ORDER_END_DATE IS NULL;


-- IS NOT NULL : NULL이 아닌 데이터 조회
SELECT *
FROM (
	SELECT TBO.*, TBP.PRODUCT_BRAND , TBP.PRODUCT_PRICE 
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID
)
WHERE ORDER_END_DATE IS NOT NULL;


-- 문자열 함수
--CONCAT (값, 값) 
SELECT CONCAT('안녕', '하세요') -- -> 컬럼도 가능하다
FROM DUAL;

SELECT 'HELLO' || 'WORLD' AS "인사" FROM DUAL;


--LENGTH
SELECT LENGTH ('HELLO' || 'WORLD' ) AS "인사" FROM DUAL;

-- SUBSTR(문자열, 글자 위치, 몇 개까지 가지고 올까) : 문자열 추출 -> 인덱스 1부터 시작
-- MYSQL - SUBSTRING

SELECT SUBSTR('오늘 점심 뭐 먹지?', 4, 2) FROM DUAL;


--
CREATE SEQUENCE SEQ_SQLD_PRODUCT;
CREATE TABLE TBL_SQLD_PRODUCT(
	ID NUMBER CONSTRAINT PK_SQLD_PRODUCT PRIMARY KEY,
	SQLD_PRODUCT_NAME VARCHAR2(225),
	SQLD_PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '키보드', 20000);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '모티터', 30000);




CREATE SEQUENCE SEQ_SQLD_ORDER;
CREATE TABLE TBL_SQLD_ORDER(
	ID NUMBER CONSTRAINT PK_SQLD_ORDER PRIMARY KEY,
	SQLD_ORDER_NAME VARCHAR2(225),
	SQLD_PRODUCT_ID NUMBER,
	CONSTRAINT FK_SQLD_ORDER_SQLD_PRODUCT FOREIGN KEY(SQLD_PRODUCT_ID)
	REFERENCES TBL_SQLD_PRODUCT(ID)
);

INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL,'문 앞 배송', 1);
INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL,'직접 수령', 2);
INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL,'문 앞 배송', 2);




-- 중복 연산자
--1. DISTINCT : 조회 결과의 중복을 제거
--2. UNION : 중복 제거하고, 두 컬럼 데이터 조회를 합친다. 합집합
SELECT SQLD_PRODUCT_NAME
FROM TBL_SQLD_PRODUCT 
UNION
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;
-- 지우개, 키보드, 모니터, 문 앞 배송, 직접 수령

--3. UNION ALL : 중복을 제거하지 않고, 두 컬럼 데이터 조회를 합친다.  합집합
SELECT SQLD_PRODUCT_NAME
FROM TBL_SQLD_PRODUCT 
UNION ALL
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

--4. MINUS : 차집합
SELECT SQLD_PRODUCT_NAME
FROM TBL_SQLD_PRODUCT 
MINUS
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

--5. INTERSECT : 교집합

-- IS NULL : NULL 이면 TRUE
-- IS NOT NULL : NULL 이 아니면 TRUE
-- ====================================================================================================================
-- 함수
--=============================================================================================================

--UPPER: 대문자로
SELECT UPPER('hell') FROM DUAL;

--LOWER: 소문자로
SELECT LOWER ('DDAT') FROM DUAL;

--TRIM: 양쪽 공백 없이
SELECT TRIM('NICE TO MEET YOU') FROM DUAL

--REPLACE (값, 바꿀 값, 바뀔 값)
SELECT REPLACE ('      NICE TO MEET YOU', ' ', '') FROM DUAL;


--INSTR 인덱스 찾기 ( 값, 위치가 궁금한 )
SELECT INSTR('강사님 질문해도 될까요', '질문') FROM DUAL; 

-- 날짜 함수
--SYSDATE 
SELECT SYSDATE FROM DUAL;

SELECT CURRENT_DATE FROM DUAL;

--ADD_MONTHS
SELECT ADD_MONTHS(SYSDATE, 2) FROM DUAL; 
SELECT ADD_MONTHS(SYSDATE, -2) FROM DUAL; 

--MONTHS_BETWEEN 달 차이
SELECT MONTHS_BETWEEN('2024-07-12', SYSDATE) FROM DUAL;

--TO_DATE 월 차이
SELECT TO_DATE(SYSDATE) - TO_DATE('2024-07-12') FROM DUAL; 

-- 일 차이
SELECT TO_TIMESTAMP(SYSDATE) - TO_TIMESTAMP('2024-07-12') FROM DUAL; 


-- 달 차이
-- MONTHS_BETWEEN()

SELECT MONTHS_BETWEEN(SYSDATE, '2024-07-12') FROM DUAL;  
-- 일 차이
SELECT (SYSDATE - TO_DATE('2025-09-15 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) FROM DUAL;

-- 시 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 FROM DUAL;

-- 분 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 FROM DUAL;

-- 초 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 * 60 FROM DUAL;

-- NEXT_DAY()
-- 특정 날짜 이후의 지정된 요일이 반환
SELECT NEXT_DAY(SYSDATE, '월요일') FROM DUAL; 

--TRUNC(): 날짜의 시각을 제거하고 날짜만 반환
SELECT 
TRUNCATE 
SELECT * FROM TBL_INCOME;



SELECT TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS'),
	TO_CHAR(
	 TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS'), 'HH')AS "TIME",
	TO_CHAR(
	 TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS'), 'MI')AS "MI",
	TO_CHAR(
	 TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS'), 'YYYY')AS "YYYY"
	FROM DUAL;


--ABS() : 절대값을 반환
SELECT ABS(-12) FROM DUAL;

--CEIL : 올림
SELECT CEIL(12.3) FROM DUAL;

-- FLOOR 내림
SELECT FLOOR(3.9) FROM DUAL;


-- MOU : 나머지
SELECT MOU(5,2) FROM DUAL;

--POWER : 거듭 제곱


-- 변환 함수
SELECT TO_NUMBER('11.23') + 10 FROM DUAL;

SELECT TO_TIMESTAMP('2025-02-25 16:40:00', 'YYYY-MM-DD HH24:MI:SS') FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;

SELECT CAST(10 AS VARCHAR2(225) FROM DUAL;

SELECT CAST('2025-02-27' AS DATE) FROM DUAL;

-- NULL 함수 ***********
-- 1. NVL(값1, 값2) 첫 번째 값이면 NULL이면, 두 번쨰 값이면 리턴
SELECT NVL(NULL, '대체 값') FROM DUAL;


-- 2. NVL2(값1, 값2, 값3) 값 중 NULL 이 아닌 값을 반환
SELECT NVL2(NULL, 'TRUE', 'FALSE') FROM DUAL


--3. COALESCE (값1, 값2, 값3....) 값 중 NULL 이 아닌 첫 번째 값을 반환
SELECT COALESCE(NULL, 0, NULL, 15) FROM DUAL;

SELECT NULLIF(10, 15) FROM DUAL 	
--조건식에 
--IS NULL
--IS NOT NUL  


-- CASE 문

SELECT
	CASE PRODUST_GENDER
		WHEN '남' 



-- START WITH
--CONNECT BY PRIOR 부모 자식 관계

